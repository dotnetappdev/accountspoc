/*!
 * Custom Chart.js-compatible implementation for AccountsPOC
 * Minimal chart rendering library inspired by Chart.js API
 * Supports line, bar, and doughnut chart types
 * (c) 2024 AccountsPOC Project
 * Released under the MIT License
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).Chart=e()}(this,(function(){"use strict";

class Chart {
    constructor(ctx, config) {
        this.ctx = ctx.getContext ? ctx.getContext('2d') : ctx;
        this.canvas = ctx.canvas || ctx;
        this.config = config;
        this.data = config.data;
        this.options = config.options || {};
        this.type = config.type;
        this._init();
    }

    _init() {
        // Ensure canvas has valid dimensions
        if (!this.canvas.offsetWidth || !this.canvas.offsetHeight) {
            this.canvas.width = 400;
            this.canvas.height = 300;
        } else {
            this.canvas.width = this.canvas.offsetWidth;
            this.canvas.height = this.canvas.offsetHeight;
        }
        this.draw();
    }

    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        switch(this.type) {
            case 'line':
                this._drawLine();
                break;
            case 'bar':
                this._drawBar();
                break;
            case 'doughnut':
            case 'pie':
                this._drawDoughnut();
                break;
        }
    }

    _drawLine() {
        const ctx = this.ctx;
        const data = this.data.datasets[0].data;
        const labels = this.data.labels;
        
        // Validate data
        if (!data || data.length === 0 || !labels || labels.length === 0) {
            this._drawEmptyState('No data available');
            return;
        }
        
        const padding = 50;
        const chartWidth = this.canvas.width - 2 * padding;
        const chartHeight = this.canvas.height - 2 * padding;
        
        const max = Math.max(...data);
        if (max <= 0) {
            this._drawEmptyState('No positive data values');
            return;
        }
        
        // Handle single data point
        const step = data.length > 1 ? chartWidth / (data.length - 1) : chartWidth / 2;
        
        // Draw axes
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, padding + chartHeight);
        ctx.lineTo(padding + chartWidth, padding + chartHeight);
        ctx.stroke();
        
        // Draw line
        ctx.strokeStyle = this.data.datasets[0].borderColor || '#4bc0c0';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        data.forEach((value, index) => {
            const x = padding + (step * index);
            const y = padding + chartHeight - (value / max * chartHeight);
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        ctx.stroke();
        
        // Fill area if specified
        if (this.data.datasets[0].fill) {
            ctx.fillStyle = this.data.datasets[0].backgroundColor || 'rgba(75, 192, 192, 0.1)';
            ctx.beginPath();
            // Redraw the line path for filling
            data.forEach((value, index) => {
                const x = padding + (step * index);
                const y = padding + chartHeight - (value / max * chartHeight);
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.lineTo(padding + (step * (data.length - 1)), padding + chartHeight);
            ctx.lineTo(padding, padding + chartHeight);
            ctx.closePath();
            ctx.fill();
        }
        
        // Draw points
        ctx.fillStyle = this.data.datasets[0].borderColor || '#4bc0c0';
        data.forEach((value, index) => {
            const x = padding + (step * index);
            const y = padding + chartHeight - (value / max * chartHeight);
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, 2 * Math.PI);
            ctx.fill();
        });
        
        // Draw labels
        ctx.fillStyle = '#666';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        labels.forEach((label, index) => {
            const x = padding + (step * index);
            ctx.fillText(label, x, padding + chartHeight + 20);
        });
    }

    _drawBar() {
        const ctx = this.ctx;
        const datasets = this.data.datasets;
        const labels = this.data.labels;
        
        // Validate data
        if (!datasets || datasets.length === 0 || !labels || labels.length === 0) {
            this._drawEmptyState('No data available');
            return;
        }
        
        const padding = 50;
        const chartWidth = this.canvas.width - 2 * padding;
        const chartHeight = this.canvas.height - 2 * padding;
        
        const allData = datasets.flatMap(d => d.data);
        const max = Math.max(...allData);
        if (max <= 0) {
            this._drawEmptyState('No positive data values');
            return;
        }
        
        const barWidth = (chartWidth / labels.length) / (datasets.length + 1);
        
        // Draw axes
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, padding + chartHeight);
        ctx.lineTo(padding + chartWidth, padding + chartHeight);
        ctx.stroke();
        
        // Draw bars
        datasets.forEach((dataset, dsIndex) => {
            dataset.data.forEach((value, index) => {
                const x = padding + (chartWidth / labels.length) * index + barWidth * dsIndex + 10;
                const height = (value / max) * chartHeight;
                const y = padding + chartHeight - height;
                
                ctx.fillStyle = dataset.backgroundColor || '#36a2eb';
                ctx.fillRect(x, y, barWidth, height);
                ctx.strokeStyle = dataset.borderColor || '#36a2eb';
                ctx.strokeRect(x, y, barWidth, height);
            });
        });
        
        // Draw labels
        ctx.fillStyle = '#666';
        ctx.font = '11px Arial';
        ctx.textAlign = 'center';
        labels.forEach((label, index) => {
            const x = padding + (chartWidth / labels.length) * index + (chartWidth / labels.length) / 2;
            ctx.fillText(label, x, padding + chartHeight + 20);
        });
        
        // Draw legend
        if (datasets.length > 1) {
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            datasets.forEach((dataset, index) => {
                const x = padding + index * 100;
                const y = 20;
                ctx.fillStyle = dataset.backgroundColor || '#36a2eb';
                ctx.fillRect(x, y, 15, 15);
                ctx.fillStyle = '#666';
                ctx.fillText(dataset.label, x + 20, y + 12);
            });
        }
    }

    _drawDoughnut() {
        const ctx = this.ctx;
        const data = this.data.datasets[0].data;
        const labels = this.data.labels;
        
        // Validate data
        if (!data || data.length === 0 || !labels || labels.length === 0) {
            this._drawEmptyState('No data available');
            return;
        }
        
        const colors = this.data.datasets[0].backgroundColor || [
            '#4bc0c0', '#ffce56', '#36a2eb', '#ff6384', '#9966ff', '#ff9f40'
        ];
        
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const radius = Math.min(centerX, centerY) - 60;
        const innerRadius = radius * 0.6;
        
        const total = data.reduce((sum, val) => sum + val, 0);
        if (total <= 0) {
            this._drawEmptyState('No positive data values');
            return;
        }
        
        let currentAngle = -Math.PI / 2;
        
        // Draw segments
        data.forEach((value, index) => {
            const sliceAngle = (value / total) * 2 * Math.PI;
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
            ctx.arc(centerX, centerY, innerRadius, currentAngle + sliceAngle, currentAngle, true);
            ctx.closePath();
            
            ctx.fillStyle = colors[index % colors.length];
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            currentAngle += sliceAngle;
        });
        
        // Draw legend
        ctx.font = '12px Arial';
        ctx.textAlign = 'left';
        const legendX = 20;
        const legendY = this.canvas.height - (labels.length * 25);
        
        labels.forEach((label, index) => {
            const y = legendY + index * 25;
            ctx.fillStyle = colors[index % colors.length];
            ctx.fillRect(legendX, y, 15, 15);
            ctx.fillStyle = '#666';
            ctx.fillText(`${label}: ${data[index]}`, legendX + 20, y + 12);
        });
    }

    update() {
        this.draw();
    }

    _drawEmptyState(message) {
        const ctx = this.ctx;
        ctx.fillStyle = '#999';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(message, this.canvas.width / 2, this.canvas.height / 2);
    }

    destroy() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

// Register as global Chart
if (typeof window !== 'undefined') {
    window.Chart = Chart;
}

return Chart;
}));
